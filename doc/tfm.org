#+startup:fold
#
* TFM : the Trigger Farm Manager                                             
- forked from artdaq_daqinterface/fc/control/DAQInterface.py
- goals : 
  - reduce number of transitions
  - get rid of symlinks in the logfile naming
  - make sure that the server can provide any diagnostics information needed for 
  - split configurations from teh farm managr scripts themselves
    troubleshooting the farm performance
  - integrate with MIDAS as a frontend client
* [[file:artdaq_daqinterface.org]]
* ------------------------------------------------------------------------------
* [[file:software_setup.org][software setup]]
* TODO [0/1]  farm_manager.py: server managing the trigger farm              
** command line parameters                                                   
- example: 
#+begin_src
configuration=vst_001
partition=8
source tfm_configure $configuration $partition
$TFM_DIR/rc/control/farm_manager.py --config-dir=$PWD/config/$configuration
#+end_src
** Comments:
   -- env['ARTDAQ_PARTITION_NUMBER'] is set by tfm_configure and used by the farm_manager

   -- the TFM port number = 10000+1000*partition_number, no need to improvise

   -- the configuration dir could be anywhere, and TFM should not be making assumptions
      about it

   -- after sourcing the [[file:../bin/tfm_configure][tfm_configure]] script, only need to specify the configuration directory 
      (when debugging a given configuration, may want to create a copy)

|--------------------+---------------------------------+------+-------------+--------------------------------------------------------------------|
| flag               | description                     | Type | default     | comment                                                            |
|--------------------+---------------------------------+------+-------------+--------------------------------------------------------------------|
| -n, --name         | component name (what is that ?) | str  | "daqint"    |                                                                    |
| -H, --rpc-host     | This hostname/IP addr           | str  | "localhost" |                                                                    |
| -c, --control-host | Control host                    | str  | "localhost" |                                                                    |
|--------------------+---------------------------------+------+-------------+--------------------------------------------------------------------|
| -d, --debug-level  | debug level                     | int  | -1          | if specified, overrides settings in boot.txt                       |
|--------------------+---------------------------------+------+-------------+--------------------------------------------------------------------|
| -D, --config-dir   | config directory                | str  | None        | contains all configuration files, has to be defined                |
|                    |                                 |      |             | on the command line. Last config-dir path component (subdirectory) |
|                    |                                 |      |             | is the configuration name                                          |
|--------------------+---------------------------------+------+-------------+--------------------------------------------------------------------|
- knows about: BoardReader, EventBuilder, DataLogger, Dispatcher, RoutingManager
- at startup, TFM goes directly into a 'booted' state
- 'config' step defines new run number and configures the farm for that
- start 
- stop actually stops the procecesses, so new 'configure' is needed
- however, the TFM is in 'ready' state, so cant run 'congig' transition
- shutdown transitions the farm from 'ready' to 'booted' state
- not clear, what it actually is doing
- but after 'shutdown' can do next 'config'
- need to figure the difference between the 'terminate' and 'shutdown'
- states  : Ready, Running, Paused, Stopped
- commands: Init , Start, Pause, Resume, Stop, Shutdown
- transition commands sent by [[file:../bin/tfm_transition][tfm_transition]]
  - boot,
  - config
  - start :
    - if run number is not defined, use next one to the last found
    - if run number is defined, use that, send "starting struct/{run_number:i/$rn}"
  - enable
  - disable
  - stop
  - terminate
** TODO [0/1] internal variables and their quirks                            
*** TODO debug_level: when set to zero,  the environment gets corrupted      
    for the moment, set to 1, and work around
* configuration                                                              
- the farm configuration consists of the following files:
-   boot.txt : defines components the farm configuration
-   [[file:settings.org][settings]] : defined additional farm configuration parameters               
-              (to be merged with boot.txt)
-   .FCL files : one file per component                                       
-                component 'x' has its FCL file named 'x.fcl'
- the FCL files are copied from $TFM_FHICL_DIRECTORY/$config_name to a temp 
-      directory created in /tmp/`uuidgen` by 
-      [[file:../rc/control/farm_manager.py::/def check_hw_fcls/]]
-      see self.get_config_info() there 
-      after being copied, they are checked for being unique - not sure how one 
-      can make such a mistake
-      also what are multiple subconfigurations ?

* TFM transitions                                                            
- defined in [[file:../bin/tfm_transition]]                                      
- commands are translated, and sent to the TF server are the translated commands. 
- "translated" commands are different from the original ones by "ing" 
- what is it? a linquistic exersize of defining gerunds ?
|-----------+--------------------+---------------+----------------------------------|
| command   | translated command | XMLRPC string | comment                          |
|-----------+--------------------+---------------+----------------------------------|
| boot      | booting            |               | obsolete, performed upon startup |
| config    | configuring        |               |                                  |
| start     | starting           |               |                                  |
| enable    | enabling           |               | obsolete                         |
| disable   | disabling          |               | obsolete                         |
| stop      | stopping           |               |                                  |
| shutdown  | shutting           |               | included into stop               |
| terminate | terminating        |               | obsolete                         |
|-----------+--------------------+---------------+----------------------------------|

1) TFM assumes that all config files , including FCLs are located in a directory 
provided to it at a startup , so the rest transitions do not really need a configuration
parameter
2) startup executed old boot
3) run number is specified at old config
4) new start doesn't execute old config - config should be a separate step , 
   as there are multiple subsystems, and at 'configured' all shoudl be ready to run
5) stop is stop, after stop - either configure or shutdown
6) at 'shutdown', the farm manager exits, requiring a new start
* [[file:test_examples.org][test examples]]                                                               
* [[file:environment_variables.org][environment variables]]                                                      
* farm management methods                                                    
  management methods ("direct", "pmt", "external_run_control") are defined in 
   [[file:../rc/control/farm_manager.py::/process_management_methods/]]
* xmlrpc                                                                     
** checkout code                                                             
svn checkout http://svn.code.sf.net/p/xmlrpc-c/code/stable xmlrpc-c

** https://www.xml.com/pub/a/2001/10/29/xmlrpc.html - the most useful link   
- snippet which creates a struct 
- array uses round brackets
#+begin_src
result = xmlrpc_client_call( &env,
                             url,
                             "some_func",
                             "({s:i,s:i})",
                             "my great argument", 1,
                             "my next argument",  2
                           )
#+end_src
** https://xmlrpc-c.sourceforge.io/doc/xmlrpc.html
** http://xmlrpc.com/         
** RPC2 manual: http://www.coda.cs.cmu.edu/doc/html/rpc2_manual.html
** code examples: https://xmlrpc-c.sourceforge.io/example-code.php
** status                                                                    
#+begin_src                                                                   
                xmlrpc http://localhost:$TFM_PORT/RPC2 state daqint
#+end_src 
** TODO listdaqcomps                                                         
for some reason, listdaqcomps output doesn't show up on the screen immediately, 
but it shows up when the next command is executed - a TODO item
#+begin_src                                                                  
xmlrpc http://localhost:$TFM_PORT/RPC2 listdaqcomps
#+end_src
** listconfigs                                                               
- lists available farm configurations defined in subdirectories of the $TFM_FHICL_DIRECTORY
- output saved in /tmp/listconfigs_mu2etrk.txt 
#+begin_src                                                                  
mu2etrk@mu2edaq09:~/test_stand/pasha_019>xmlrpc http://localhost:$TFM_PORT/RPC2 listconfigs
Available configurations: 
ascii_simulator_example
circular_buffer_mode_example
circular_buffer_mode_withRM
complex_subsystems
complicated_subsystems
config_includes
demo
demo_largesystem
dune_sample_system
eventbuilder_diskwriting
file_closing_example
mediumsystem_with_routing_manager
missed_requests
mu2e_sample_system
multiple_art_processes_example
multiple_dataloggers
multiple_fragment_ids
multiple_fragments_per_read
pdune_swtrig_DFO
protodune_mock_system
request_based_dataflow_example
routing_manager_example
simple_subsystems
subconfigs
subrun_example
See file "/tmp/listconfigs_mu2etrk.txt" for saved record of the above configurations

Please note that for the time being, the optional
max_configurations_to_list variable which may be set in
/home/mu2etrk/test_stand/pasha_019/tfm_test/settings is only applicable
when working with the database
Result:

Nil
#+end_src 
* [[file:./communication_with_artdaq.org][communication with artdaq]]
* log file naming                                                            
  [[file:../rc/control/farm_manager.py::/def determine_logfilename/]]

  log file names defined during the boot transition 
  -- do_boot
     -- get_artdaq_log_filenames
        -- determine_logfilename

  -- logfiles are created at boot step, on my laptop/docker this step for config='demo'
     took from 00:07:53 to 00:09:03, out of that:
  -- 38 sec - not sure what
  -- 10 sec - check of the setup script
  -- 19 sec - launch of the artdaq processes
  --  2 sec - associating log files

  self.launch_attempt_files[p.host] : PMT log file (used in manage_processes_direct.py
  
- all art processes have their COUT redirected to the PMT log file

- however, messages by message_facility go into individual log files, one per 
art process
* TFM command line scripts                                                   
** [[file:../bin/tfm_configure][tfm_configure]] : setup active artdaq configuration
** tfm_transition                                                            
- handles transitions: config, start, stop, 
- doesn't handle yet: pause, resume, shutdown
#+begin_src
mu2etrk@mu2edaq09:~/test_stand/pasha_020>tfm_transition stop
[tfm_transition:7] : parameters:stop
[tfm_transition:96] full_cmd=xmlrpc http://localhost:18000/RPC2 state_change daqint stopping 'struct/{ignored_variable:i/999}'
Result:

Nil
#+end_src
** artdaq_process_info.sh                                                    
- call signature:
#+begin_src
      artdaq_process_info.sh [partition]
#+end_src
- if partition is specified, it is used to determine the communication port number 
- otherwise, the value of $TFM_PARTITION is used

** tfm_status (obsolete)                                                     
- returns old state w/o completion                            
#+begin_src

#+end_src 
** [[file:../bin/tfm_get_status][tfm_get_status]]                                                            
- returns status of the farm (with completion percentage for transisitons)
- stable states always report completion at 100%, i.e. 'running:100'
- perhaps, rewrite in python to parse
#+begin_src
mu2etrk@mu2edaq09:~/test_stand/pasha_020>tfm_get_status
'configured:100'
#+end_src
** [[file:../bin/tfm_start][tfm_start]] : start the farm manager, the script needs more debugging
** [[file:../bin/tfm_shutdown][tfm_shutdown]] : stop all processes, shutdown the farm, stop the TFM
* [[file:./dqm.org][DQM]]
* error codes                                                                
- 140: 
* ------------------------------------------------------------------------------
* [[file:work_in_progress.org][work_in_progress]]
* ------------------------------------------------------------------------------
